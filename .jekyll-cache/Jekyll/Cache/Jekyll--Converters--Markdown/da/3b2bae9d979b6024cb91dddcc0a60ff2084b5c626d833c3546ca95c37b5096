I"I<link rel="stylesheet" href="/css/pygments.css" />

<p>作者: Jakob Jenkov</p>

<p>　　本小节会简要概括Java IO中的PushbackInputStream，SequenceInputStream和PrintStream。其中，最常用的是PrintStream，System.out和System.err都是PrintStream类型的变量，请查看<a href="http://leesir.github.io/2015/10/java-io-systemstream/">Java IO: System.in, System.out, System.err</a>浏览更多关于System.out和System.err的信息。</p>

<p>#PushbackInputStream</p>

<p>　　<a href="http://tutorials.jenkov.com/java-io/pushbackinputstream.html">原文链接</a></p>

<p>　　PushbackInputStream用于解析InputStream内的数据。有时候你需要提前知道接下来将要读取到的字节内容，才能判断用何种方式进行数据解析。PushBackInputStream允许你这么做，你可以把读取到的字节重新推回到InputStream中，以便再次通过read()读取。代码如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="nc">PushbackInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PushbackInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\data\\input.txt"</span><span class="o">));</span>

<span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>

<span class="n">input</span><span class="o">.</span><span class="na">unread</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    </code></pre></figure>

<p>　　可以通过PushBackInputStream的构造函数设置推回缓冲区的大小，代码如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="nc">PushbackInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PushbackInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\data\\input.txt"</span><span class="o">),</span> <span class="mi">8</span><span class="o">);</span>
    </code></pre></figure>

<p>　　这个例子设置了8个字节的缓冲区，意味着你最多可以重新读取8个字节的数据。</p>

<!-- more -->

<p>#SequenceInputStream</p>

<p>　　<a href="http://tutorials.jenkov.com/java-io/sequenceinputstream.html">原文链接</a></p>

<p>　　SequenceInputStream把一个或者多个InputStream整合起来，形成一个逻辑连贯的输入流。当读取SequenceInputStream时，会先从第一个输入流中读取，完成之后再从第二个输入流读取，以此推类。代码如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="nc">InputStream</span> <span class="n">input1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\data\\file1.txt"</span><span class="o">);</span>

<span class="nc">InputStream</span> <span class="n">input2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"c:\\data\\file2.txt"</span><span class="o">);</span>

<span class="nc">InputStream</span> <span class="n">combined</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SequenceInputStream</span><span class="o">(</span><span class="n">input1</span><span class="o">,</span> <span class="n">input2</span><span class="o">);</span>
    </code></pre></figure>

<p>　　通过SequenceInputStream，例子中的2个InputStream使用起来就如同只有一个InputStream一样(译者注：SequenceInputStream的read()方法会在读取到当前流末尾时，关闭流，并把当前流指向逻辑链中的下一个流，最后返回新的当前流的read()值)。</p>

<p>#PrintStream</p>

<p>　　<a href="http://tutorials.jenkov.com/java-io/printstream.html">原文链接</a></p>

<p>　　PrintStream允许你把格式化数据写入到底层OutputStream中。比如，写入格式化成文本的int，long以及其他原始数据类型到输出流中，而非它们的字节数据。代码如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="nc">PrintStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">outputStream</span><span class="o">);</span>

<span class="n">output</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="n">output</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="mi">123</span><span class="o">);</span>

<span class="n">output</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="mf">123.456</span><span class="o">);</span>

<span class="n">output</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="nc">Locale</span><span class="o">.</span><span class="na">UK</span><span class="o">,</span> <span class="s">"Text + data: %1$"</span><span class="o">,</span> <span class="mi">123</span><span class="o">);</span>

<span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    </code></pre></figure>

<p>　　PrintStream包含2个强大的函数，分别是format()和printf()(这两个函数几乎做了一样的事情，但是C程序员会更熟悉printf())。</p>

<p>　　译者注：其中一个printf()函数实现如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="kd">public</span> <span class="nc">PrintStream</span> <span class="nf">printf</span><span class="o">(</span><span class="nc">String</span> <span class="n">format</span><span class="o">,</span> <span class="nc">Object</span> <span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">return</span> <span class="nf">format</span><span class="o">(</span><span class="n">format</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>

<span class="o">}</span>
    </code></pre></figure>
:ET