<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Derrick Lee's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/theme.css" rel="stylesheet">
</head>

<body>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse"
                        data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="combine-header">
                <a class="navbar-brand" href="/">Derrick Lee's Blog</a>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav">
                        <li class="active"><a href="/">Home</a></li>
                        <li class="active visible-xs-block"><a href="/links.html">Links</a></li>
                        <li class="active"><a href="/archive.html">Archive</a></li>
                        <li class="active"><a href="/categories.html">Categories</a></li>
                        <li class="active"><a href="/tags.html">Tags</a></li>
                        <li class="active"><a href="/about.html">About</a></li>
                        
                        <li class="active"><a href="https://github.com/leesir/leesir.github.io">Github</a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>



<div class="container container-left">
    <div class="row">
        <div class="col-md-3 hidden-xs">
            <div class="sidebar well">
    <h4>Stay foolish, Stay ugly</h4>
</div>

<div class="sidebar well">
    <h1>Recent Posts</h1>
    <ul>
        
        <li><a href="/2019/07/java-sugar-generic-type-erasure">Java语法糖-泛型-类型擦除</a></li>
        
        <li><a href="/2019/07/java-sugar-generic">Java语法糖-泛型</a></li>
        
        <li><a href="/2019/06/cache-pattern-practise">缓存更新策略实践</a></li>
        
        <li><a href="/2019/06/java-javasuger-cc">Java语法糖-条件编译</a></li>
        
        <li><a href="/2019/06/java-assert">Java语法糖-assert</a></li>
        
        <li><a href="/2019/06/system-logincache">一种基于redis的登录态的设计与实现</a></li>
        
        <li><a href="/2019/06/java-javasuger-innerclass">Java语法糖-内部类</a></li>
        
        <li><a href="/2019/06/java-javasuger">Java语法糖</a></li>
        
        <li><a href="/2016/08/java-history">Java的历史</a></li>
        
        <li><a href="/2016/07/java-history-beginning-words">Java历史开篇语</a></li>
        
        <li><a href="/2016/07/project-summary-2">项目总结-2016年07月11日</a></li>
        
        <li><a href="/2016/07/project-summary-1">Project Summary 1</a></li>
        
        <li><a href="/2016/07/summary-synchronized-error">对包装类型变量使用synchronized不当造成的同步不正确</a></li>
        
        <li><a href="/2016/07/boxed-type-conditional-op">包装类型在条件运算中的使用不当造成的空指针异常</a></li>
        
        <li><a href="/2015/11/java-cr-code-convention">Java代码规范实践手册</a></li>
        
    </ul>
</div>

<div class="sidebar well">
    <h1>Links</h1>
<ul>
  <li><a href="http://ifeve.com/" target="_blank">并发编程网</a></li>
  <li><a href="http://www.infoq.com/cn" target="_blank">InfoQ</a></li>
</ul>

</div>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1277778288'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277778288%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
        </div>
        <div class="col-md-9">
            
<div class="article">
    <div class="well">
        <h1><a href="/2019/07/java-sugar-generic-type-erasure">2019-07-04  Java语法糖-泛型-类型擦除</a></h1>
        
        <div class="content">
		<link rel="stylesheet" href="/css/pygments.css" />

<p>       Java编译器将会对泛型代码进行以下擦除逻辑：</p>

<ul>
  <li>如果泛型不存在类型边界，则使用Object类替代泛型。</li>
  <li>如果泛型存在类型边界，则使用边界的类型替代泛型。</li>
  <li>编译器自动加入类型转换代码。</li>
  <li>存在继承关系的泛型类，编译器将生成桥接方法，在类型擦除过后依然保留多态特性。</li>
</ul>

<p>       在Java的字节码文件中，只存在普通的类、接口或者方法。泛型擦除不会引入新的类，所以不会产生额外的运行时开销。</p>

<p><br /></p>

<h2 id="代码示例">代码示例</h2>

<p><br /></p>

<p>       泛型类和泛型方法的擦除逻辑一致，我们以泛型类为例进行说明，不再赘述泛型方法的逻辑。</p>

<p><br /></p>

<h4 id="1-无类型边界的泛型类的擦除">1. 无类型边界的泛型类的擦除</h4>

<p>       我们定义一个泛型测试类：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericClassErasureTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;&gt;(</span><span class="s">"tail"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getData</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">T</span> <span class="n">data</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">T</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure1</p>

<p><br /></p>

<p>       因为没有类型边界，所以编译器会将泛型转换成Object，实际上Node类应该是这样的：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Object</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Object</span> <span class="n">data</span><span class="o">,</span> <span class="n">Node</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure2</p>

<p><br /></p>

<p>       特别说明：在使用intelliJ IDEA或者JD-GUI等反编译图形工具，查看泛型类字节码时，依然可以看到泛型信息，这于大家所熟悉的“编译之后泛型擦除”的说法相悖。
可以用javap -verbose查看class文件的虚拟机指令。以代码清单generic-type-erasure1的Node类为例，运行javap之后的输出如下所示（仅截取方法描述）：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//构造函数</span>
<span class="kd">public</span> <span class="n">generic</span><span class="o">.</span><span class="na">erasure</span><span class="o">.</span><span class="na">GenericClassErasureTest</span><span class="n">$Node</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">generic</span><span class="o">.</span><span class="na">erasure</span><span class="o">.</span><span class="na">GenericClassErasureTest</span><span class="n">$Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;);</span>
<span class="nl">descriptor:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span><span class="n">Lgeneric</span><span class="o">/</span><span class="n">erasure</span><span class="o">/</span><span class="n">GenericClassErasureTest$Node</span><span class="o">;)</span><span class="n">V</span>

<span class="c1">//getData方法</span>
<span class="kd">public</span> <span class="n">T</span> <span class="nf">getData</span><span class="o">();</span>
<span class="nl">descriptor:</span> <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;</span></code></pre></figure>

<p>       描述符descriptor展示了方法的参数和返回值的类型，参数类型会按照方法声明的顺序展示在括号()内，返回值类型紧跟其后。
如果没有参数，则显示()。如果没有返回值，则显示V。</p>

<p>       可以看到，getData的返回值类型是Ljava/lang/Object，也就是类型为Object，证明了字节码中的泛型会转换成具体的类型，而字节码中的泛型T，则属于具体类型的别名。
事实上，在引入泛型后，字节码新增了Signatures部分，用以记录不属于JVM类型系统的语言级别的类型信息。Signatures的官网说明如下：</p>

<blockquote>
  <p>Signatures are used to encode Java programming language type information that is not part of the Java Virtual Machine type system, such as generic type and method declarations and parameterized types.</p>

  <p>This kind of type information is needed to support reflection and debugging, and by a Java compiler.</p>
</blockquote>

<p>       所以，准确来说，在字节码中能够察觉泛型的存在（这也是反编译工具能够还原泛型的原因），但同时泛型也被具体化了，泛型类被编译成了处理具体类型的普通类。</p>

<p><br /></p>

<h4 id="2-有类型边界的泛型类的擦除">2. 有类型边界的泛型类的擦除</h4>

<p>       我们同样定义一个泛型测试类：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">UpperBoundTypeClass</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">data</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">UpperBoundTypeClass</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure3</p>

<p><br /></p>

<p>       同样截取方法签名，如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//getData方法</span>
<span class="kd">public</span> <span class="n">T</span> <span class="nf">getData</span><span class="o">();</span>
<span class="nl">descriptor:</span> <span class="o">()</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">String</span><span class="o">;</span></code></pre></figure>

<p>       可以看到方法的实际返回值是String而非Object。</p>

<p><br /></p>

<h4 id="3-类型擦除的多态处理桥接方法">3. 类型擦除的多态处理——桥接方法</h4>

<p>       当编译一个参数化的类或接口的子类或实现类时（以下统称子类），除了类型擦除，编译器还会额外对子类生成桥接方法。
开发者不需要关心桥接方法，但最好还是了解一下编译器的行为，避免被堆栈信息疑惑。考虑如下代码：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="n">data</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Node.setData"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">MyNode</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyNode.setData"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure4</p>

<p><br /></p>

<p>       当类型擦除之后，Node类的setData变成setData(Object data)，而MyNode的setData方法参数类型为Integer，所以MyNode的setData没有覆盖Node类的setData，未能实现多态。
为了让类型擦除之后的继承关系依然保留多态，编译器为子类新生成了以下方法：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Bridge method generated by the compiler</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setData</span><span class="o">((</span><span class="n">Integer</span><span class="o">)</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure5</p>

<p><br /></p>

<p>       在代码清单generic-type-erasure5中，新的setData与Node类的setData拥有相同的方法签名，实现了多态，方法内部通过强制类型转换，再调用了原先的setData(Integer data)。
同样可以用javap验证这一点，以下是MyNode的setData(Object data)的字节码内容的截取片段：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">);</span>
<span class="nl">descriptor:</span> <span class="o">(</span><span class="n">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">Object</span><span class="o">;)</span><span class="n">V</span>
<span class="o">...</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="mi">6</span>                  <span class="c1">// class java/lang/Integer</span>
<span class="o">...</span></code></pre></figure>

<p><br /></p>

<h2 id="总结">总结</h2>

<p><br /></p>

<h2 id="附件">附件</h2>

<p>       本博文所展示的源代码<a href="https://github.com/leesir/blog_code/tree/master/src/generic/erasure">由此获得</a>。</p>

<p><br /></p>

<h2 id="参考文献">参考文献</h2>

<p>[1] Josh Juneau.<a href="https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html">泛型：工作原理及其重要性</a>[EB/OL].https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html，2019-07-02.<br />
[2] <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">The Java™ Tutorials - Generics</a>[EB/OL].https://docs.oracle.com/javase/tutorial/java/generics/index.html，2019-07-02.<br />
[3] <a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.3">The Java® Virtual Machine Specification</a>[EB/OL].https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.3，2019-07-04.<br /></p>

		<h1><a href="/2019/07/java-sugar-generic-type-erasure">阅读全文</a></h1>
        </div>
    </div>
</div>

<div class="article">
    <div class="well">
        <h1><a href="/2019/07/java-sugar-generic">2019-07-02  Java语法糖-泛型</a></h1>
        
        <div class="content">
		<link rel="stylesheet" href="/css/pygments.css" />

<h2 id="前言">前言</h2>

<p><br /></p>

<p>       JDK自1.5版本引入泛型机制，代码中常用的容器类（如java.util.Collection和java.util.Map）都属于泛型类。泛型的引入带来了以下好处：</p>

<ul>
  <li>在使用集合类时，将以往JDK版本的类型错配报错，由运行时提前到了编译期，使得代码不再需要处理ClassCastException。</li>
  <li>在访问泛型元素时，不再需要强制转换对象类型，代码更加简洁优雅。</li>
  <li>泛型提高了代码复用率。</li>
</ul>

<p><br /></p>

<p class="center"><img src="/images/post_2019_07_02_image1.png" alt="c compile" /></p>

<p class="center"><a href="https://www.nextptr.com/series/a554793983/explained-java-generics-and-collections">图片来源</a></p>

<p><br /></p>

<p>       由于Java泛型属于语法糖，编译过后会将泛型信息擦除。相较于C++和C#的泛型，Java的泛型更像是伪泛型，因为JVM中没有泛型的概念，完全是编译器的magic。</p>


		<h1><a href="/2019/07/java-sugar-generic">阅读全文</a></h1>
        </div>
    </div>
</div>

<div class="article">
    <div class="well">
        <h1><a href="/2019/06/cache-pattern-practise">2019-06-27  缓存更新策略实践</a></h1>
        
        <div class="content">
		<link rel="stylesheet" href="/css/pygments.css" />

<h2 id="前言">前言</h2>

<p>       缓存在计算机的世界中是一个非常宽泛的概念，因为处处是缓存的身影。操作系统可能缓存DNS的解析结果，浏览器可能缓存页面静态元素，用户访问的资源可能缓存在CDN中，
CPU可能会缓存操作数所属的内存块，数据库的查询结果也可能是缓存好的。总之不管是在系统架构中的哪一层级，都有缓存的实现。所以，抛开具体应用谈缓存是没有意义的，那样过于空泛，但可以肯定的是，所有的缓存都是利用了数据的冗余提高性能，空间换时间，计算机的世界充斥着trade off。</p>

<p>       本博文基于项目中的实际应用整理而来，仅讨论在DB和业务代码之间的缓存服务，主要分析笔者经历的项目中，根据不同的业务，采用了哪些更新策略（注，不讨论缓存的替换策略，如LRU等）。</p>

<p><br /></p>

<p class="center"><img src="/images/post_2019_06_27_image1.jpg" alt="c compile" /></p>

<p class="center"><a href="http://web.sfc.keio.ac.jp/~rdv/computer-architecture-2018-wiki/index.php?Memory%20Subsystems">图片来源</a></p>


		<h1><a href="/2019/06/cache-pattern-practise">阅读全文</a></h1>
        </div>
    </div>
</div>

<div class="article">
    <div class="well">
        <h1><a href="/2019/06/java-javasuger-cc">2019-06-24  Java语法糖-条件编译</a></h1>
        
        <div class="content">
		<link rel="stylesheet" href="/css/pygments.css" />

<h2 id="前言">前言</h2>

<p><br /></p>

<p>       条件编译，顾名思义，就是有条件地对代码进行编译，对于一套源代码，不同条件可能会编译出不同的两套目标代码。
条件完全不同于if语句。if语句属于代码逻辑，不管哪个代码分支都会被编译。而条件编译只会编译满足条件的分支的代码。</p>

<p>       条件编译广泛存在于需要跨平台运行的程序里，在真正开始编译之前，预处理过程会把代码扫描一遍，进行初步转换，其中一项任务就是执行条件编译。
在C和C++中，由预处理命令实现条件编译。预处理命令由#开头，比如#ifdef：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//程序处于调试阶段，可以将调试日志打印出来 </span>
<span class="err">#</span><span class="n">ifdef</span> <span class="n">DEBUG</span></code></pre></figure>

<p>       因C\C++的编译会最终生成目标机器的可执行文件，可执行文件是与平台极其相关的，因此C\C++程序可能会出现同一份代码需要分别根据平台进行编译的情况。</p>

<p class="center"><img src="/images/post_2019_06_24_image1.jpg" alt="c compile" /></p>

<p class="center"><a href="https://computer.howstuffworks.com/c1.htm">图片来源</a></p>


		<h1><a href="/2019/06/java-javasuger-cc">阅读全文</a></h1>
        </div>
    </div>
</div>

<div class="article">
    <div class="well">
        <h1><a href="/2019/06/java-assert">2019-06-21  Java语法糖-assert</a></h1>
        
        <div class="content">
		<link rel="stylesheet" href="/css/pygments.css" />

<p>       在谈断言之前，必须要谈谈2种编程方式：防御性编程与契约式编程。防御性编程来自于《代码大全》，契约式编程由伯特兰·迈耶于1986年提出。</p>

<p>       防御性编程强调不信任外部输入的参数，要对所有可能出现问题的数据加以判断，这种编程方式的代码中，通常存在大量重复的if语句。</p>

<p>       契约式编程强调系统内各组件必须按规定实现各自的逻辑，在组件交互的过程中不对参数进行校验，如果发现参数不符合要求，程序将立即终止执行。
现代编程语言通过断言的机制实现契约式编程，这种编程方式的代码比较简洁。</p>

<p>       然而在现今的软件开发过程中，不可能实现契约式编程：人员流动大、不愿意写文档、不愿意看文档、需求迭代快。
当然防御性编程也做的不好，否则就不会由bug了。甚至有时候某种做法属于防御性编程还是契约式编程都不清晰，比如使用注解式参数校验框架，看似属于契约式编程：代码简洁、快速失效。
而当反编译过后，实则大量基础if判断。</p>

<p>       防御性编程与契约式编程思想的出现，都算的上是软件开发思想的进步，而受制于当时的知识背景，难免在今天略显过时。就此结束讨论，进入正题。</p>


		<h1><a href="/2019/06/java-assert">阅读全文</a></h1>
        </div>
    </div>
</div>


<div class="pagination">
  
  <span class="page_number ">Page: 1 of 11</span>
  
    <a class="btn btn-default" href="/page2" class="next">Older</a>
  
</div>

        </div>
    </div>
</div>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="span12 footer navbar-inverse navbar-fixed-bottom">
            <p class="copyright">&copy;2019 Derrick Lee's Blog. Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme by <a href="https://github.com/scotte/jekyll-clean">Scott Emmons</a>
            under
            <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution</a></p>
        </div>
    </div>
</div>






</body>
</html>

