<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Derrick Lee's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/theme.css" rel="stylesheet">
</head>

<body>

<div class="container-fluid">
    <div class="row-fluid">
        <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse"
                        data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div class="combine-header">
                <a class="navbar-brand" href="/">Derrick Lee's Blog</a>
                <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                    <ul class="nav navbar-nav">
                        <li class="active"><a href="/">Home</a></li>
                        <li class="active visible-xs-block"><a href="/links.html">Links</a></li>
                        <li class="active"><a href="/archive.html">Archive</a></li>
                        <li class="active"><a href="/categories.html">Categories</a></li>
                        <li class="active"><a href="/tags.html">Tags</a></li>
                        <li class="active"><a href="/about.html">About</a></li>
                        
                        <li class="active"><a href="https://github.com/leesir/leesir.github.io">Github</a></li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>



<div class="container container-left">
    <div class="row">
        <div class="col-md-3 hidden-xs">
            <div class="sidebar well">
    <h4>Stay foolish, Stay ugly</h4>
</div>

<div class="sidebar well">
    <h1>Recent Posts</h1>
    <ul>
        
        <li><a href="/2019/09/prod-jvm-params">生产环境JVM参数配置记录（一）</a></li>
        
        <li><a href="/2019/08/bug-1">工作问题记录（一）：事务的错误使用方式</a></li>
        
        <li><a href="/2019/07/accurate-money">一种精确的理财金额算法的设计与实现（以等额本息为例）</a></li>
        
        <li><a href="/2019/07/java-sugar-generic-relate">Java语法糖-泛型-类关系</a></li>
        
        <li><a href="/2019/07/java-sugar-generic-wildcard">Java语法糖-泛型-通配符</a></li>
        
        <li><a href="/2019/07/java-sugar-generic-bound">Java语法糖-泛型-泛型边界</a></li>
        
        <li><a href="/2019/07/java-sugar-generic-type-erasure">Java语法糖-泛型-类型擦除</a></li>
        
        <li><a href="/2019/07/java-sugar-generic">Java语法糖-泛型</a></li>
        
        <li><a href="/2019/06/cache-pattern-practise">缓存更新策略实践</a></li>
        
        <li><a href="/2019/06/java-javasuger-cc">Java语法糖-条件编译</a></li>
        
        <li><a href="/2019/06/java-assert">Java语法糖-assert</a></li>
        
        <li><a href="/2019/06/system-logincache">一种基于redis的登录态的设计与实现</a></li>
        
        <li><a href="/2019/06/java-javasuger-innerclass">Java语法糖-内部类</a></li>
        
        <li><a href="/2019/06/java-javasuger">Java语法糖</a></li>
        
        <li><a href="/2016/08/java-history">Java的历史</a></li>
        
    </ul>
</div>

<div class="sidebar well">
    <h1>Links</h1>
<ul>
  <li><a href="http://ifeve.com/" target="_blank">并发编程网</a></li>
  <li><a href="http://www.infoq.com/cn" target="_blank">InfoQ</a></li>
</ul>

</div>

<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
document.write(unescape("%3Cspan id='cnzz_stat_icon_1277778288'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277778288%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
        </div>
        <div class="col-md-9">
            <div class="article">
                <div class="well">
                    <h1><a href="/2019/07/java-sugar-generic-type-erasure">Java语法糖-泛型-类型擦除</a></h1>
                    <br>
                    
                    <div class="post-content">
                        <link rel="stylesheet" href="/css/pygments.css" />

<p>       在Java的字节码文件中，只存在普通的类、接口或者方法。泛型擦除不会引入新的类，所以不会产生额外的运行时开销Java编译器将会对泛型代码进行以下擦除逻辑：</p>

<ul>
  <li>如果泛型不存在类型边界，则使用Object类替代泛型。</li>
  <li>如果泛型存在类型边界，则使用边界的类型替代泛型。</li>
  <li>编译器自动加入类型转换代码。</li>
  <li>存在继承关系的泛型类，编译器将生成桥接方法，在类型擦除过后依然保留多态特性。</li>
</ul>

<p><br /></p>

<h2 id="代码示例">代码示例</h2>

<p><br /></p>

<p>       泛型类和泛型方法的擦除逻辑一致，我们以泛型类为例进行说明，不再赘述泛型方法的逻辑。</p>

<p><br /></p>

<h4 id="1-无类型边界的泛型类的擦除">1. 无类型边界的泛型类的擦除</h4>

<p>       我们定义一个泛型测试类：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericClassErasureTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;&gt;(</span><span class="s">"tail"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getData</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="no">T</span> <span class="n">data</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="no">T</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure1</p>

<!-- more -->

<p><br /></p>

<p>       因为没有类型边界，所以编译器会将泛型转换成Object，实际上Node类应该是这样的：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">data</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Object</span> <span class="n">data</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
    <span class="c1">// ...</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure2</p>

<p><br /></p>

<p>       特别说明：在使用intelliJ IDEA或者JD-GUI等反编译图形工具，查看泛型类字节码时，依然可以看到泛型信息，这于大家所熟悉的“编译之后泛型擦除”的说法相悖。
可以用javap -verbose查看class文件的虚拟机指令。以代码清单generic-type-erasure1的Node类为例，运行javap之后的输出如下所示（仅截取方法描述）：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//构造函数</span>
<span class="kd">public</span> <span class="n">generic</span><span class="o">.</span><span class="na">erasure</span><span class="o">.</span><span class="na">GenericClassErasureTest</span><span class="n">$Node</span><span class="o">(</span><span class="no">T</span><span class="o">,</span> <span class="n">generic</span><span class="o">.</span><span class="na">erasure</span><span class="o">.</span><span class="na">GenericClassErasureTest</span><span class="n">$Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;);</span>
<span class="nl">descriptor:</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;</span><span class="nc">Lgeneric</span><span class="o">/</span><span class="n">erasure</span><span class="o">/</span><span class="nc">GenericClassErasureTest</span><span class="n">$Node</span><span class="o">;)</span><span class="no">V</span>

<span class="c1">//getData方法</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">getData</span><span class="o">();</span>
<span class="nl">descriptor:</span> <span class="o">()</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;</span></code></pre></figure>

<p>       描述符descriptor展示了方法的参数和返回值的类型，参数类型会按照方法声明的顺序展示在括号()内，返回值类型紧跟其后。
如果没有参数，则显示()。如果没有返回值，则显示V。</p>

<p>       可以看到，getData的返回值类型是Ljava/lang/Object，也就是类型为Object，证明了字节码中的泛型会转换成具体的类型，而字节码中的泛型T，则属于具体类型的别名。
事实上，在引入泛型后，字节码新增了Signatures部分，用以记录不属于JVM类型系统的语言级别的类型信息。Signatures的官网说明如下：</p>

<blockquote>
  <p>Signatures are used to encode Java programming language type information that is not part of the Java Virtual Machine type system, such as generic type and method declarations and parameterized types.</p>

  <p>This kind of type information is needed to support reflection and debugging, and by a Java compiler.</p>
</blockquote>

<p>       所以，准确来说，在字节码中能够察觉泛型的存在（这也是反编译工具能够还原泛型的原因），但同时泛型也被具体化了，泛型类被编译成了处理具体类型的普通类。</p>

<p><br /></p>

<h4 id="2-有类型边界的泛型类的擦除">2. 有类型边界的泛型类的擦除</h4>

<p>       我们同样定义一个泛型测试类：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">UpperBoundTypeClass</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">data</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">UpperBoundTypeClass</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getData</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure3</p>

<p><br /></p>

<p>       同样截取方法签名，如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">//getData方法</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">getData</span><span class="o">();</span>
<span class="nl">descriptor:</span> <span class="o">()</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">String</span><span class="o">;</span></code></pre></figure>

<p>       可以看到方法的实际返回值是String而非Object。</p>

<p><br /></p>

<h4 id="3-类型擦除的多态处理桥接方法">3. 类型擦除的多态处理——桥接方法</h4>

<p>       当编译一个参数化的类或接口的子类或实现类时（以下统称子类），除了类型擦除，编译器还会额外对子类生成桥接方法。
开发者不需要关心桥接方法，但最好还是了解一下编译器的行为，避免被堆栈信息疑惑。考虑如下代码：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="no">T</span> <span class="n">data</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Node.setData"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyNode</span> <span class="kd">extends</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">MyNode</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyNode.setData"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure4</p>

<p><br /></p>

<p>       当类型擦除之后，Node类的setData变成setData(Object data)，而MyNode的setData方法参数类型为Integer，所以MyNode的setData没有覆盖Node类的setData，未能实现多态。
为了让类型擦除之后的继承关系依然保留多态，编译器为子类新生成了以下方法：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Bridge method generated by the compiler</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="nc">Object</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setData</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">data</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p class="center">代码清单generic-type-erasure5</p>

<p><br /></p>

<p>       在代码清单generic-type-erasure5中，新的setData与Node类的setData拥有相同的方法签名，实现了多态，方法内部通过强制类型转换，再调用了原先的setData(Integer data)。
同样可以用javap验证这一点，以下是MyNode的setData(Object data)的字节码内容的截取片段：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setData</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">);</span>
<span class="nl">descriptor:</span> <span class="o">(</span><span class="nc">Ljava</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="nc">Object</span><span class="o">;)</span><span class="no">V</span>
<span class="o">...</span>
<span class="mi">2</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="mi">6</span>                  <span class="c1">// class java/lang/Integer</span>
<span class="o">...</span></code></pre></figure>

<p><br /></p>

<h2 id="附件">附件</h2>

<p>       本博文所展示的源代码<a href="https://github.com/leesir/blog_code/tree/master/src/generic/erasure">由此获得</a>。</p>

<p><br /></p>

<h2 id="参考文献">参考文献</h2>

<p>[1] Josh Juneau.<a href="https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html">泛型：工作原理及其重要性</a>[EB/OL].https://www.oracle.com/technetwork/cn/articles/java/juneau-generics-2255374-zhs.html，2019-07-02.<br />
[2] <a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">The Java™ Tutorials - Generics</a>[EB/OL].https://docs.oracle.com/javase/tutorial/java/generics/index.html，2019-07-02.<br />
[3] <a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.3">The Java® Virtual Machine Specification</a>[EB/OL].https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.3，2019-07-04.<br /></p>

                    </div>
                    
                </div>
            </div>
            <div class="pagination">
                
                <a class="btn btn-default" href="/2019/07/java-sugar-generic-bound" class="next">Newer Post</a>
                
                
                <a class="btn btn-default" href="/2019/07/java-sugar-generic" class="previous">Older
                    Post</a>
                
            </div>
        </div>
    </div>

    

    <div class="container-fluid">
    <div class="row-fluid">
        <div class="span12 footer navbar-inverse navbar-fixed-bottom">
            <p class="copyright">&copy;2019 Derrick Lee's Blog. Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme by <a href="https://github.com/scotte/jekyll-clean">Scott Emmons</a>
            under
            <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution</a></p>
        </div>
    </div>
</div>






</body>
</html>


</div>